---
title: "[Scala] Basic Introduction of Scala"
description: >-
  함수형 프로그래밍을 이해하고, Scala 언어의 기본 문법을 정리합니다.
author: rammer
date: 2025-09-10 00:32:00 +0900
permalink: /posts/scala_1/
categories: [Scala]
tags: [Scala, PL]
use_math: true
toc: true
pin: false
media_subpath: '/posts/20250910'

---
  * 수식이 제대로 보이지 않는다면, 새로고침(F5)을 해주시기 바랍니다.  
  * 고려대학교 박지혁 교수님의 '프로그래밍언어(COSE212)'를 기반으로 했습니다.  


## Functional Programming(FP)
Scala 언어에서는 함수형 프로그래밍(FP)을 하기 굉장히 유용하다. 대입문을 사용하지 않고, 각 문제를 해결하기 위한 코드를 함수로 작성하는 프로그래밍 방식을 함수형 프로그래밍이라 한다. FP를 하면 예기치 못한 문제(부수 효과, Side Effects)를 줄이거나, 가독성 높은 코드를 짜는데 도움이 된다.  
Side Effects로는 변수의 값 변경, 예외 및 오류 발생으로 인한 실행 중단, 객체의 필드값 설정 등이 있고, 이를 제거한 함수를 Pure Function이라 한다.  


앞으로 작성할 Scala 코드는 모두 FP 스타일로 할 예정이다.  
이제부터 Scala의 기본 자료형을 알아보자.

## Basic Data Types
scala> 42  
val res0: Int = 42

scala> 3.7  
val res1: Double = 3.7

scala> true  
val res2: Boolean = true

scala> 'c'  
val res3: Char = c

scala> "abc"  
val res4: String = abc

### Operations
scala> "abc".length  
val res5: Int = 3

scala> println(println("HI"))  
HI  
()  //Unit


## Immutable Variables
val (variable name): (variable type) = initial value의 형태로 사용한다. 값을 변경할 수 없다.  

```scala
val x: Int = 1
x + 2
```

```scala
val y = 1
val c = true
```
이렇게 사용해도 Type Inference가 있기 때문에 Data Type이 정해진다.

## Methods
def add(x: Int, y: Int) : Int = x + y의 형태로 사용할 수 있다.  
add 부분은 method name이 들어가는 곳이다. x, y 부분은 parameter name, 괄호 안 Int 부분은 parameter type 부분이다. 콜론 뒤에 있는 Int 부분에는 함수의 return type이 들어간다. 마지막으로 method body가 = 뒤에 들어간다.  

### Examples
```scala
def add(x: Int, y: Int): Int = x + y
add(1, 2)
```

## Conditionals
if (x < 0) -x else x의 형태로 사용할 수 있다. abs 함수를 예시로 만들어보자.  
```scala
def abs(x: Int): Int = if (x < 0) -x else x

abs(12)
abs(-5)
```

## Recursions
Scala에서는 함수형 프로그래밍을 지향하며, 재귀적 프로그래밍에 매우 유용하다. 아래와 같이 재귀적으로 프로그램을 작성할 수 있다.  
```scala
// A program that calculates sum of integers from 1 to n
def sum(n: Int): Int =
  if (n < 1) 0
  else sum(n - 1) + n

sum(10)
sum(100)
```

## case class
product type을 선언하는 방식이다. tuple과 비슷하게 여길 수 있다.  
case class Point(x: Int, y: Int, color: String)의 형식으로 선언할 수 있다. Scala에서 다음과 같이 실행해보았다.

scala> case class Point(x: Int, y: Int, color: String)  
// defined case class Point  

scala> val p: Point = Point(3, 4, "RED")  
val p: Point = Point(3,4,RED)  

## enums
Algebraic Data Types(ADTs) 중 하나인 enum 선언 방법을 알아보자.  

scala> enum Tree {  
     | case Leaf(value: Int)  
     | case Branch(left: Tree, value: Int, right: Tree)}  
// defined class Tree  

scala> import Tree.*  //이 부분이 있어야 Tree 내부의 constructor들을 불러와 직접 사용 가능하다.  

scala> val tree1: Tree = Leaf(1)  
val tree1: Tree = Leaf(1)  

scala> val tree2: Tree = Branch(Leaf(1), 2, Leaf(3))  
val tree2: Tree = Branch(Leaf(1),2,Leaf(3))  

## Pattern Matching
ADTs에 pattern match를 하는 것이 가능하다. 아래와 같은 방법을 사용할 수 있다.  

scala> enum Tree {  
     | case Leaf(value: Int)  
     | case Branch(left: Tree, value: Int, right: Tree)  
     | }  
// defined class Tree  

scala> import Tree.*  

scala> def sum(t: Tree): Int = t match {  
     | case Leaf(n) => n  
     | case Branch(l, n, r) => sum(l) + n + sum(r)  
     | }  

```scala
sum(Branch(Leaf(1), 2, Leaf(3))) // 결과로 6이 나온다.
```

## Methods

또한 다음처럼 case class 안에 def를 활용하여 method를 선언할 수 있다. .move() 이런 방식으로 사용할 수 있다.  
```scala
case class Point(x: Int, y: Int, color: String) {
  def move(dx: Int, dy: Int): Point = Point(x+dy, y+dy, color)
}
Point(3, 4, "RED").move(1, -2)
```

또한 this 키워드를 사용하여 다음과 같이 작성할 수 있다.  
```scala
enum Tree {
  case Leaf(value: Int)
  case Branch(left: Tree, value: Int, right: Tree)


  // This is a method finding integer in Tree.
  def count(x: Int): Int = this match {
    case Leaf(n) if n == x => 1
    case Leaf(_)           => 0
    case Branch(l, n, r) if n == x => l.count(x) + 1 + r.count(x)
    case Branch(l, _, r)           => l.count(x) + r.count(x)
  }
}

import Tree.*
val t = Branch(
  Branch(Leaf(1), 2, Leaf(3)),
  2,
  Branch(Leaf(2), 4, Leaf(2))
)

println(t.count(2))  // 결과: 4가 나온다. 트리에는 2가 4개 있기 때문이다.
```

참고로 예시의 트리 모양은 다음과 같다. 

        2
       / \
      2   4
     / \ / \
    1  3 2  2

## First-Class Functions
Scala에서 함수는 value로 취급한다. 즉, function은 1급 객체(first-class citizen)이다. 1급 객체란, 아래의 3가지 조건을 만족해야 하는 객체이다.  

1. 변수나 데이터에 할당할 수 있다.
2. 객체의 인자로 넘길 수 있다.
3. 객체의 리턴값으로 리턴할 수 있다.
<br>
  
Kotlin의 그 1급 객체랑 같은 의미이다. Scala에서도 마찬가지이다.  

x에다 1을 더하는 함수는 (x: Int) => x + 1로 쓸 수 있다. 이 때, 함수 자체도 변수에 대입이 가능하여 다음처럼 코드를 작성할 수 있다.  
```scala
val inc: Int => Int = (x: Int) => x + 1

inc(3)
```
즉, inc에 대입하는 내용이 (x: Int) => x + 1이고, inc의 data type은 Int=>Int형이다. Int를 넣으면 Int를 반환하는 함수를 넣을 수 있는 타입이란 뜻이다.  
해괴망측하지만 ((x: Int) => x + 1)(3)의 결과는 4이다.  
참고로 (x: Int) => x + 1를 더욱 간편하게 쓸 수 있는 방법도 있다.  
```scala
val inc1: Int => Int = (x: Int) => x + 1
val inc2: Int => Int = x => x + 1 // Type Inference
val inc3: Int => Int = _ + 1 // Placeholder Syntax
```
inc1, inc2, inc3 세 함수 모두 같은 기능을 한다.  

다음은 함수를 argument로 넘길 수 있는 것의 예제이다.  
```scala
def twice(f: Int => Int, x: Int): Int = f(f(x))

twice((x: Int) => x + 1, 5)
```

다음은 함수를 리턴값으로 사용하는 예시이다.
```scala
val addN = (n: Int) => (x: Int) => x + n
val add2 = addN(2)
add2(3)
addN(7)(5)
```

## Lists
리스트(List)는 우리가 흔히 아는 그 리스트가 맞다. List[T]라고 하면, type T의 원소의 immutable한 sequence를 의미한다. 예제를 보면 바로 알 수 있다.  

```scala
val list: List[Int] = List(3, 1, 2, 5, 4)
val list2 = 1 :: 2 :: 3 :: 4 :: 5 :: Nil //List(1, 2, 3, 4, 5)와 같은 의미
list(1)
```

중요한 점은 List 역시 immutable하다는 것이다.  

### pattern match in Lists
List에서도 Pattern Matching이 가능하다. 다음 예제를 보자.  
```scala
val list: List[Int] = 3 :: 1 :: 2 :: 4 :: Nil
def getSecond(list: List[Int]): Int = list match {
  case _ :: x :: _ => x
  case _ => 0
}

getSecond(list) // list의 앞에서부터 2번 째 원소를 꺼내는 함수

```

### Opertions of Lists
List에 적용할 수 있는 여러 operation들의 종류이다. 아래 예제를 살펴보자.  
```scala
val list: List[Int] = List(3, 1, 2, 4)

list.length // 4
list.map(_ * 2) // List(6, 2, 4, 8)
list.filter(_ % 2 == 1) // List(3, 1)
list.foldLeft(0)(_ + _) // 10, because 0 + 3 + 1 + 2 + 4
list.flatMap(x => List(x, -x)) // List(3, -3, ..., 4, -4)
list.map(x => List(x, -x)).flatten // List(3, -3, ..., 4, -4)
list.sum
```

.length: 원소 개수 반환  
.map(): 각 원소에 함수를 적용해 동일 길이의 새 리스트 반환  
.filter(): 조건을 만족하는 함수만 남김  
.flatMap(f: A => List[B]): List[B]는 각 원소를 List로 변환하고 결과들을 이어붙여 하나의 리스트로 만든다.  
.sum은 리스트 원소의 합을 계산하며, 원소는 반드시 Numeric 타입이어야 한다. (Int, Double, ...)  

## Pairs
pair(T, U)의 형태로 쓸 수 있다. c++ STL의 그 pair와 똑같이 생각하면 된다.  
  
```scala
val pair: (Int, String) = (123, "HELLO")
```

## Maps
Map은 type K인 key로부터 type V인 value로 매핑을 하는 type이다. 다음과 같이 쓸 수 있다.  
```scala
val map: Map[String, Int] = Map("a" -> 1, "b" -> 2, "c" -> 3)
map + ("c" -> 3) // Map("a" -> 1, "b" -> 2)
map("a")
map.get("a") // Some(1)
```

map()으로 값을 얻을 수 있는데, .get()을 사용하면 Option 타입을 얻을 수 있다. Option type이란, map 안에 값이 있으면 Option[type]을 반환해주고, 없을 경우에는 None을 반환해준다. .get()을 사용하지 않고, map()으로 값을 얻으려고 시도하는데, 값이 없다면 에러가 발생한다.  

## Sets
Set[T]은 type T의 서로 다른 원소들이 모여 있는 집합이다. 집합이기 때문에 같은 원소는 서로 달라야 한다.  
```scala
val set1: Set[Int] = Set(1, 2, 3)
val set2: Set[Int] = Set(2, 3, 5)

set1 + 4
set1 - 2
set1.contains(2) // true
set1 ++ set2 // Set(1, 2, 3 ,5)
set1.intersect(set2) // Set(2, 3)
```

## for comprehension
for comprehension은 nested map, flatMap, filter 등을 위한 간결한 문법이다. python의 list comprehension을 안다면 이를 이해하기 쉽다. scala의 for comprehensio과 같은 간결한 문법을 문법 설탕(syntactic sugar)라고 한다.<br>

사용 예시는 다음과 같다.  
```scala
for {
  x <- xlist
  y <- ylist
  if (x+y) % 2 ==0
} yield x * y
```

## Conclusion
지금까지 핵심적인 scala 문법에 대해 알아보았다. scala 문법을 새롭게 알게될 때 마다 이곳에 내용을 추가할 예정이다.










